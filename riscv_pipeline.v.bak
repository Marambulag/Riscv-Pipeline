// cpu.v
// Top-level module for the RISC-V pipeline (initial stages: Fetch, IF/ID Reg, Decode)

module cpu (
    input wire clk,
    input wire reset,
    // Add any other top-level inputs/outputs here as your CPU grows
    // For example, memory interfaces, debug signals, etc.
    output wire [31:0] debug_current_pc_if_stage, // For debugging Fetch stage PC
    output wire [31:0] debug_instr_id_stage       // For debugging Decode stage instruction
);

    // ----------------------------------------------------
    // Wires for IF/ID Pipeline Register Connections
    // ----------------------------------------------------

    // From Fetch (IF) Stage Outputs
    wire [31:0] if_instr_to_reg;       // Instruction fetched from memory
    wire [31:0] if_pc_plus_4_to_reg;   // PC + 4 (for JAL and next sequential instruction)
    wire [31:0] if_current_pc_to_reg;  // Current PC value from Fetch stage

    // To Decode (ID) Stage Inputs (coming from IF/ID Register outputs)
    wire [31:0] id_instr_from_reg;       // Instruction for Decode stage
    wire [31:0] id_pc_plus_4_from_reg;   // PC + 4 for Decode stage
    wire [31:0] id_pc_from_reg;          // Current PC for Decode stage (e.g., for JAL base)

    // Wires related to Write-Back (WB) stage for Forwarding to Decode
    // These will eventually come from the MEM/WB register (or the WB stage itself).
    // For now, they are hardcoded to zero, meaning no active WB forwarding.
    wire        wb_RegWriteW;
    wire [4:0]  wb_rdW;
    wire [31:0] wb_resultW;

    assign wb_RegWriteW = 1'b0;
    assign wb_rdW       = 5'b00000;
    assign wb_resultW   = 32'b0;


    // ----------------------------------------------------
    // IF Stage - Instruction Fetch
    // ----------------------------------------------------
    fetch IF_stage_inst (
        .clk(clk),
        .reset(reset),
        // These inputs control PC selection (will connect to EX stage branch/jump logic later)
        .pc_src_sel_in(4'b0000),     // Default to PC+4 (adjust as needed if fetch has different default)
        .branch_target_in(32'b0),    // Default to 0
        .jump_target_in(32'b0),      // Default to 0

        .instr(if_instr_to_reg),          // Output instruction to IF/ID Register
        .pc_plus_4(if_pc_plus_4_to_reg),  // Output PC+4 to IF/ID Register
        .current_pc(if_current_pc_to_reg) // Output current PC to IF/ID Register
    );

    // ----------------------------------------------------
    // IF/ID Pipeline Register
    // ----------------------------------------------------
    if_id_register IF_ID_reg_inst (
        .clk(clk),
        .reset(reset),
        .if_instr_in(if_instr_to_reg),           // Connect from Fetch output
        .if_pc_plus_4_in(if_pc_plus_4_to_reg),   // Connect from Fetch output
        .if_current_pc_in(if_current_pc_to_reg), // Connect from Fetch output

        .id_instr_out(id_instr_from_reg),         // Output to Decode input
        .id_pc_plus_4_out(id_pc_plus_4_from_reg), // Output to Decode input
        .id_pc_out(id_pc_from_reg)                // Output to Decode input
    );

    // ----------------------------------------------------
    // ID Stage - Instruction Decode
    // ----------------------------------------------------
    // Note: The 'decode' module takes inputs for its control_unit, imm_gen, etc.
    // Ensure the output wires from 'decode' are declared and connected to the next stage (ID/EX register)
    // for when you implement it. For now, they can be unconnected if not used at this top-level.
    decode ID_stage_inst (
        .clk(clk),
        .reset(reset),
        .instr(id_instr_from_reg),          // Connect from IF/ID Register output
        .pc_in(id_pc_from_reg),             // Connect from IF/ID Register output (for JAL/JALR base)
        .pc_plus_4_in(id_pc_plus_4_from_reg), // Connect from IF/ID Register output (for JAL link)

        .RegWriteW(wb_RegWriteW), // From future WB stage (for forwarding)
        .rdW(wb_rdW),             // From future WB stage (for forwarding)
        .resultW(wb_resultW),     // From future WB stage (for forwarding)

        // Outputs of the Decode stage (will go to the ID/EX register)
        // Declare these wires and connect them to the next stage's inputs when you build ID/EX.
        .rdata1(), .rdata2(), .imm_ext(), .rs1(), .rs2(), .rd(),
        .opcode(), .funct3(), .funct7(), .RegWrite(), .MemRead(),
        .MemWrite(), .ALUOp(), .ALUSrc(), .Branch(), .Jump(), .ResultSrc()
    );

    // ----------------------------------------------------
    // Debug Outputs (Optional, for easy waveform viewing)
    // ----------------------------------------------------
    assign debug_current_pc_if_stage = if_current_pc_to_reg;
    assign debug_instr_id_stage = id_instr_from_reg;

endmodule