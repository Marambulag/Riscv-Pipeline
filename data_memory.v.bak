module data_memory (
    input logic clk,
    input logic [31:0] addr,       // Address from ALU result
    input logic [31:0] write_data, // Data to write (from rdata2_out from EX/MEM)
    input logic [1:0] mem_write,   // Control signal: 00=no write, 01=byte, 10=half, 11=word
    input logic mem_read,       // Control signal: 1=read, 0=no read
    output logic [31:0] read_data   // Data read from memory
);

// Assuming a simple synchronous memory, adjust depth as needed
localparam DATA_MEM_DEPTH = 256; // Example: 256 words (1KB)
reg [31:0] mem [DATA_MEM_DEPTH-1:0];

// Initialize memory (optional, for simulation)
initial begin
    for (int i = 0; i < DATA_MEM_DEPTH; i++) begin
        mem[i] = 32'b0; // Initialize all locations to 0
    end
    // You can also load from a .mem file here if needed
    // $readmemh("data_memory.mem", mem);
end

// Memory write
always_ff @(posedge clk) begin
    if (mem_write == 2'b11) begin // Word write (SW)
        mem[addr[9:2]] <= write_data; // Align to word address (addr[31:2])
    end
    // Add logic for byte (SB) and half-word (SH) writes if supported
end

// Memory read
always_comb begin
    if (mem_read) begin
        read_data = mem[addr[9:2]]; // Read word, align address
    end else begin
        read_data = 32'b0; // No read, output zero
    end
    // Add logic for byte (LB, LBU) and half-word (LH, LHU) reads if supported
end

endmodule